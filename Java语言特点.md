# Java 语言特点

## 面向对象

两个基本概念 ： 类、对象
三大特征 ： 封装、继承、多态

## 健壮性

增加了垃圾回收机制

## 跨平台

由JVM来支持Java在不同的平台中运行

## 核心机制

垃圾回收

## JDK

Java Development Kit

## 编译JAVA 程序

javac 程序名.java
java 程序名

## 注释 Comment

使用// 来对代码进行注释
使用/*   */ 来进行多行注释
javadoc -d name -author -version programname

## Public 一个java源文件中可以声明多个class 但是 只能最多有一个类声明为public的 而且要求声明为public的类的类名必须与源文件名相同

## 编程风格

使用文档注释来注释整个类或整个方法
如果注释方法中的某一个步骤，使用单行或多行注释

使用一次tab操作，实现缩进
运算符两边习惯各加一个空格

## 关键子和保留字

定义数据类型的关键字

class   定义一个类 后跟类名
interface   定义一个接口 后跟接口名
enum    定义了一个枚举类型 后跟枚举名
byte    定义字节类型的变量 后跟变量名 或 值
short   定义short类型的变量 后跟变量名 或 值
int     定义整型变量 后跟变量名
long    定义长整型变量 后跟变量名
float   定义浮点型变量 后跟变量名
double  定义双精度浮点型变量 后跟变量名
char    定义字符变量 后跟变量名
boolean 定义布尔性变量 后跟变量名

定义流程控制的关键字

if  用于执行判断逻辑
else   当不满足if语句时，执行else语句
switch
case   用于条件选择
default    默认修饰符
while   用于执行循环判断逻辑
do   与while一起，while条件后所需执行的语句
for    用于循环逻辑
break   中断本次循环
continue    跳过本次循环，执行下一次循环
return    声明返回值

定义访问权限关键字

private     定义只允许在本类中所使用的元素
protected   定义允许本类及其子类中所使用的元素
public      定义全局均可使用的元素

定义类、函数、变量修饰符的关键字

abstract    定义类为抽象方法(无法实例化)
final       定义元素为不可修改的元素(可先声明后赋值)
static      定义元素为类的元素
synchronized    定义元素为线程安全的元素

定义类与类之间关系关键字

extends     表示该类继承自某个父类
implements  表示该类实现了某个(些)接口

定义实例及引用实例 判断实例的关键字

new     创建变量
this    用于类内部,代表类本身
super   用于类中,进行父类的初始化和调用父类的方法
instanceof  判断某个变量是否为某类的实例

异常处理关键字

try     启动异常处理，程序会对try关键字后续的代码块进行异常处理
catch   接收try代码块中的异常
finally 无论程序是否成功执行，均需要执行的代码块
throw
throws  抛出异常

包的关键字

package  导入jar包
import   导入类库

其他修饰符关键字

native
strictfp
transient
volatile
assert

数据类型

true    表明值为“正确”
false   表明值为“错误”
null    表明值为空

保留字

goto
const

## 标识符

java对各种变量、方法和类等要素命名时使用的字符序列称为标识符

定义规则由字母和数字、下划线和$符号组成 不包含空格
java严格区分大小写

## 命名规范

包名 ： 多单词组成时所有字母小写
类名、接口名 ： 首字母大写
变量名、方法名 ： 第一个单词首字母小写，第二个单词开始首字母大写
常量名 ： 所有字母都大写

## 变量

内存中的一个存储区域
该区域的数据可以在同一类型范围内不断变化
变量是程序中最基本的存储单元
包括 变量类型 变量名 和 存储的值

作用

用于在内存中保存数据
变量必须先声明后使用
变量只有在其作用域内才有效
同一个作用域内，不能定义重名的变量

## 数据类型

数值型

byte int short long float double char
byte  1字节
short 2字节
int   4字节
long  8字节
float 4字节
double8字节
字符型

char 使用'' 赋值

字符串

string

string 可以和其他类型进行运算(只能“+”)，运算结果仍然为string

布尔性

boolean

引用类型

类 class
接口 interface
数组 array

## 运算

### 自动类型提升

容量小的与容量大的值进行计算，自动使用容量大的类型

byte\short\char 进行运算时 结果为一个int

### 强制类型转换

变量值前面使用“()”注明 需强制转换的类型 可能导致精度丢失

## 进制表示

0b 二进制
0  八进制
0x 十六进制

## 运算符

算术运算符

/   整除

%   取余

++x 先自增 后调用变量

x++ 先调用变量 后自增

--x 先自减 后调用变量

x-- 先调用变量 后自减

赋值运算符

= 支持连续赋值

比较运算符

== 相等于

！= 不等于

<  小于

> 大于

<= 小于等于

> = 大于等于

逻辑运算符

& 逻辑与

&& 短路与

| 逻辑或
|| 短路或

！ 逻辑非
^  逻辑异或

位运算符

<< 左移

>> 右移
>>

>>> 无符号右移
>>>
>>

& 与运算

| 或运算

^ 异或运算

~ 取反运算

三元运算符

（）? A：B

条件为真 执行A 条件为假 执行B

## if 语句

if(判断条件)
{

}
else if (判断条件)
{

}
else
{

}

## switch

只能使用 byte 、short、int、char、枚举、string
switch(判断条件)
{
case 常量 :
表达式 ;
break ;
}

default 相当于 else

## 循环结构

循环结构的四个要素
1 初始化条件
2 循环条件
3 循环体
4 迭代条件

### for 循环

for(1;2;4){
3
}

### while 循环

1
while(2){
3
4
}

### do-while 循环

do-while 至少会执行一次循环体
1
do{
3
4
}while(2)

### 结束循环

break  结束最近的循环

break label  指定跳出对应循环

## 数组

数组本身是引用数据类型

数组属于引用类型,数组中的元素是任何数据类型

数组是有序排列的
数组属于引用数据类型的便能量
创建数组对象会在内存中开辟一整块连续的空间
数组的长度一旦确定 就不能修改

### 数组

数组的声明和初始化
调用数组的指定位置的元素
获取数组的长度
遍历数组
数组元素的默认初始化值
数组的内存解析

创建数组 内部元素类型 [] 数组名 = new [数组长度](或{x,x,x,x});

静态初始化 ： 直接声明数组中的元素
数组名 = new int[]{x,x,x,x}
动态初始化 ： 声明数组中的元素数量
内部元素类型 [] 数组名 = new [数组长度]

调用数组中的元素

通过 数组名[下标] 调用数组元素
从0开始到长度-1结束

获取数组长度

数组名.length

遍历数组

for 或foreach

数组初始化值

0 || 0.0 || false

## 数据结构

数据与数据间的逻辑关系 : 集合、一对一、一对多、多对多

# 数据的存储结构

线性表； 顺序表（数组）、链表、栈、队列
树形结构: 二叉树
图形结构

## 算法

1 时间复杂度
运行时间
2 空间复杂度
使用的内存空间大小
3 稳定性

## Arrays工具类

Arrays.equals 判断数组内容是否相等
Arrays.fill 填充指定值到数组
Arrays.toString 转化为字符串
Arrays.sort 排序

## 面向对象_

### 类的设计

属性
方法
构造器
代码块
内部类

堆
存放对象实例
创建出的新的对象
栈
存放局部变量
方法执行完自动释放
方法区
存放类信息、常量、静态变量、即时编译器编译后的代码

属性和局部变量

相同点

定义变量的格式：数据类型 变量名= 变量值
先声明 后使用
变量都有其对应的作用域

不同点

在类中声明的位置的不同
属性 直接定义在类的一对{}内
局部变量 声明在方法内 方法形参、代码块内、构造器形参、构造器内部的变量

方法声明没

权限修饰符 (静态) 返回值类型 方法名（形参列表）{
方法体
}

返回值

return
使用在方法体中
结束方法，传递值到方法外部

## 方法重载

“两同一不同 ”

类名、方法名相同
传入的参数不同

可变形参

String ...  允许传入多个相同类型的参数

传入为一个对应类型的数组
最多只能声明一个可变形参

## 参数传递

值传递

形参 方法定义时，声明的小括号内的参数
实参 方法调用时，实际传递给形参的数据

如果参数是基本数据类型 实参赋值的是变量所保存的数据值
如果参数是引用数据类型 实参赋值的是变量所引用的地址值

## 封装

通过修饰符 限定 变量的使用权限，创建对应的方法来提供修改和获取操作

修饰符权限

```
类内部     同一个包     不同文件的子类      所有路径
```

Private       √
缺省           √          √
Protect       √           √              √
Public        √           √              √               √

## 构造器

和类名相同的方法

1 如果没有显式定义的构造器的话，则系统默认提供一个空参的构造器
2 定义构造器的格式，权限修饰符 类名(形参列表){}
3 一个类中定义的多个构造器 彼此构成重载
4 一旦我们显式的定义了类的构造器之后，系统不再提供默认构造器
5 一个类至少有一个构造器

## 属性赋值顺序

默认初始化
显式初始化
构造器中赋值
通过对象.方法 或者 对象.属性 赋值

## JavaBean

JavaBean 是一种java语言写成的可重用组件

类是公共的
有一个无参的公共构造器
有属性 且有对应的get set方法

## this 修饰符

this 可以用来修饰\调用 ： 属性、方法、构造器

this 可以理解为当前对象 或当前正在创建的对象

在类的方法中，我们可以使用“this.属性” 或 “this.方法” 的方式，调用当前对象属性或方法
但是通常情况下，我们都选择省略“this.” 特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式 ,表明此变量是属性，而非形参；

在类的构造器中，我们可以使用“this.属性” 或 “this.方法” 的方式，调用当前对象属性或方法
但是通常情况下，我们都选择省略“this.” 特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式 ,表明此变量是属性，而非形参；

this 调用构造器
可以用this(形参列表) 调用构造器
无法调用自己本身

## Package

1 为了更好的实现项目中类的管理，提供包的概念
2 使用package声明类或接口所属的包，声明在源文件的首行
3 包属于标识符 遵循标识符的命名规则
4 每使用 一次 . 代表一层文件目录

## import

导入指定包下的类、接口
如果需要导出多个结构则并列写出即可

## 封装体现

1. 修饰符控制访问权限
2. 不对外暴露私有方法
3. 单例模式

## 继承

通过extends 来从别的类继承方法和属性
被继承的类称作父类、继承的类称为子类

一旦子类继承父类 子类就获取了父类中声明的结构、属性、方法
特别的 父类中声明为private的属性或方法、子类继承父类以后，仍然认为获取了父类中私有的结构 只是因为封装性的影响 使得子类不能直接调用父类的结构

子类继承父类后，还可以声明自己特有的属性或方法 来实现自己的功能

一个类可以被多个子类继承
Java中类的单继承性  一个类只能继承一个类

减少代码冗余 提高代码复用性
便于功能的扩展
为之后的多态性使用

## 方法的重写

在子类中可以根据需要对从父类中继承来的方法进行改造
重写以后 当创建子类对象时 通过子类对象调用父类中的同名方法 实际执行的是子类重写父类的方法

方法声明  权限修饰符 返回值类型 方法名（形参列表）{
方法体
}

子类重写的方法 方法名和形参列表与父类重写方法的方法名和形参列表相同

子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
子类不能重写父类声明为private的方法

返回值类型
父类被重写的放回置类型是void  则子类返回值类型只能是void
父类被重写方法的返回值类型是A类型 则子类返回值类型可以是A类或A的子类
子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

## Super

super 用于调用父类中的元素
可以在子类中的方法或构造器中 使用super 显式调用父类中的属性和方法

调用构造器
可以通过super() 调用父类的构造器方法
必须声明在构造器首行
构造器首行 没有显式声明this()或 super()默认调用 父类的空参构造器super()

子类的实例化
结果上看
子类继承了父类以后，就获取了父类中声明的属性和方法
创建子类的对象 在堆空间中 就会加载所有父类中声明的属性
从过程上看
当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器 直到调用了object为止

```
虽然调用了构造器  只创造了一个对象
```

## 多态

父类的引用指向子类的对象

重载  调用地址 在编译时就绑定了
多态  调用地址 在调用时绑定

## 向下转型

类型声明  类型名  = new 创建类的实例化

进行编译时 按照左侧声明类型编译 编译后对象无法调用子类自己的方法
通过强制类型转换符 才操作子类的方法和属性

instanceof 判断对象是否为某个类的实例

## equals

== 运算符

1 比较基本变量时，比较数据是否相等
2 比较引用变量时，比较内存地址是否相同

equals

是一个方法，而非运算符
只能用于引用型数据
Object类中 将equals 等价于 “==”
基础类型的equals的方法已被重写

对称性 x.equals(y) 返回true 则 y.equals(x) 也是true
自反性 x.equals(x) 返回true;
传递性 x.equals(y) 返回true; y.equals(z) 返回true 那么x.equals(z) 应该为true
一致性 x.equals(y) 返回true x,y内容不变 则一直返回true
x.equals(null) 一直为null

## toString

打印类的信息，默认打印 类名+哈希地址
通过重写toString方法 来改写输出信息

## 包装类

针对八种基本数据类型定义的相应的引用类型(包装类)
可以调用对应类的方法

基本类型 —— 包装类  自动装箱|自动拆箱
转换为String valueof();
转换为基本类型 parseInt();

## Static 关键字

1 static 类
2 static 可以用来修饰 属性、方法、代码块、内部类
3 使用static修饰属性 静态变量
实例变量 创建类的多个对象，每个对象都独立的拥有一套类中的非静态属性，当修改其中一个对象中的非静态属性，不会导致其他对象中同样的属性值的修改
静态变量 我们创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量

```
静态变量随着类的加载而加载，可以通过类名.变量来调用
静态变量的加载要早于对象的创建
类只会加载一次 静态变量在内存中也只会存在一份

静态方法 只能调用静态方法或属性
非静态方法  可以调用静态和非静态方法
```

## 初始化代码块

初始化类 和 对象
只能用static来修饰

静态代码块
随着类的加载而执行
初始化类的信息
非静态代码块
随着对象的创建而执行

静态代码块的执行优先于非静态代码块

代码块初始化和变量初始化 按顺序执行

## final

被final 修饰的类 不能被其他类继承
被final 修饰的方法 不能被重写
被final 修饰的变量 不能再被赋值

final 声明的变量可以在 变量声明、初始化代码块中进行赋值
无法在 方法中进行赋值

final 修饰局部变量

可以在参数传入时声明 或方法体内部声明

static final 全局常量

## 抽象方法

使用abstract 修饰
抽象类无法实例化
抽象类中一定有构造器
开发中 都会提供抽象类的子类 让子类对象实例化

子类必须全部实现抽象父类的方法 才可以实例化
子类如果没有实现父类的所有抽象方法 则子类也是一个抽象类

## 接口

接口中 只允许有 全局常量（final static) 和抽象方法(Java7)

允许定义静态方法、默认方法(Java8)
1接口中定义静态方法，只能通过接口来调用
2通过实现类的对象，可以调用接口中的默认方法
3如果实现类重写了接口中的默认方法，调用时 仍调用的是重写以后的方法
4如果子类或实现类 继承的父类和实现的接口中声明了同名同参数的方法 那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
5 如果实现类实现了多个接口，而这多个接口定义了同名同参数的默认方法 那么实现类没有重写此方法的情况下 报错

使用 interface 来定义
java中 接口和类是并列的两个结构

如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化
如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类.

## 内部类

当一个事物的内部 还有一个部分需要一个完整的结构进行描述 而 这个内部的完整结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类

Java 允许将一个类A 声明在另一个类B中， A被称为内部类 B为外部类

成员内部类
作为外部类的成员
调用外部类的结构
外部类.this.外部类的方法 调用外部类的属性
可以用static 修饰

```
作为一个类
    类内可以定义属性、方法、构造器等
    可以被final 修饰 表示类 不能被继承
    可以被abstract 修饰

成员内部类对象的实例化
实例化 外部类对象
使用外部类 new 内部类的对象
在成员内部类中区分调用外部类的结构
```

## 异常处理

1. 异常分为两个部分：
   Error Java虚拟机无法解决的严重问题
   Exception 其他因编程错误或偶然的外在因素导致的一般性问题 ，可以使用针对性的代码进行处理

Exception
编译异常

```
运行时异常

try-catch-finally
    自身处理
throws + 异常类型
    向上会报异常
抛 程序 在正常执行时的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象 并将此对象抛出
    手动的生成一个异常对象，并抛出（throw）
一旦抛出对象后，其后的代码就不再执行

抓 异常的处理方式

catch 接受 被抛出的异常对象 并进行相应的处理
throws 向上抛出异常

开发时 由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch 针对编译型异常 需要考虑异常处理

throws + 异常类型，匹配到异常后向上抛出
声明在方法的声明处 指明方法执行时，可能会抛出的异常类型

子类重写的方法抛出的异常范围要小于父类抛出的异常范围

父类被重写的方法没有throws方法处理异常，则子类重写的方法也不能使用throws 意味着如果子类重写的方法中有异常，必须使用try-catch-finally 来处理异常

执行方法A 先后又调用了几个方法，这几个方法是递进关系的，我们建议这几个方法使用throws的方式进行处理，而执行的方法a可以考虑使用 try-catch 来处理异常

thorw 手动声明需要抛出的异常 的关键子

自定义异常

     1. 继承现有的机场结构
     2. 提供全局常量
     3. 提供重载的构造器
            super(msg)

创建的类或方法 在其他方法下调用时 其父类方法必须处理其调用方法抛出的异常
```

线程
生命周期
程序 完成特定任务，用某种语言所编写的一组指令的结合
进程 是程序的一次执行过程，或者正在运行的一个程序
线程 进程是一个程序内部的执行路径 线程间共享内存单元和
它们从同一个堆中分配对象，可以访问相同的变量和对象，这就使得线程间通信更简便、高效、多个线程操作共享的系统资源可能会带来安全隐患

```
并行 多个CPU 执行多个任务
并发 一个CPU 同时执行多个任务

start() 调用run() 方法 执行线程功能
run() 需要使用多线程的类 继承 线程类，重写run()方法来实现线程所需要执行的操作
currentThread() 返回执行当前代码的线程
getName() 返回当前线程的线程名
setName() 设置当前线程的线程名
yield() 释放CPU的执行权
join() 执行对应线程的方法
sleep() 暂停线程多少毫秒
isalive() 判断线程是否还存活

线程的实现方式 

1 继承Thread 类 ，重写run 方法 通过start 调用该线程
2 实现runnable 接口 ， 重写run 方法 创建runnable 对象 将该对象传递给Thread类  创建对象 调用start方法 执行该线程
同步代码块
synchronized(同步监视器){
    需要被同步的代码
}
同步方法
1 同步方法仍然涉及到同步监视器，至少不需要我们显式的声明
2 非静态的同步方法，同步监视器是 this;
    静态的同步方法，同步监视器是 当前类
如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步
1 操作共享数据的代码
2 共享数据 多个线程共同操作的变量
3 同步监视器， 任何一个类的对象 都可以充当锁

死锁 
不同的线程分别占用对方需要的同步资源不释放，都在等待对方释放自己需要的资源，就形成了死锁
出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
解决方法：
专门的算法、原则
尽量减少共同资源的定义
尽量减少嵌套同步

synchronized 与 lock 异同
相同 都可以解决线程安全问题
不同 synchronized机制在执行完相应代码后，自动的释放同步监视器
     lock  需要手动  启动同步 同时结束同步也需要手动实现
使用顺序
Lock —— 同步代码块 —— 同步方法

wait 和 notify 

执行wait时 线程停止运行，释放“锁”
执行notify 通知其他线程可以运行

wait 和 sleep 
都可以暂停 线程
sleep 不会释放锁
wait 会释放锁

重写 callable 接口的call 方法 创建 futuretask 对象，通过futuretask 的get 方法 获取 该线程的返回值

线程池
    经常创建和销毁，使用量特别大的资源，比如并发情况下的线程
    堆性能影响很大

    提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建、销毁，实现重复利用，类似生活中的公共交通工具

    好处 提高响应速度
         降低资源消耗
         便于线程管理

Executors  创建线程池
execute 适合runnable
submit 适合 callable

线程的生命周期
               阻塞

创建    就绪    运行    死亡


常用类
```

## comparale 实现comparale 接口， 使实现该接口的类可以直接排序

## comparator 对于未实现该接口的类，实现该接口的匿名实现类，重写compare方法 来对值进行排序

## 枚举

枚举类的理解
类的对象只有有限个，确定的，我们称此类为枚举类
当需要定义一组常量时，使用枚举类
如果枚举类中只有一个对象，可以作为单例模式的实现方式
首先创建变量.
再创建构造方法.

## 注解

JDK 5.0新增
1 . 生成文档相关的注解
2 . 在编译时进行格式检查（JDK内置的三个基本注解）
@Override 重写方法时的检查
@Deprecated  标记过时的方法、类
@SuppressWarnings 抑制编译器警告
3 . 跟踪代码依赖性，实现替代配置文件功能

### 自定义注解

1 声明@interface
2 内部定义成员
3 可以指定默认值，使用default 定义
4 如果自定义注解没有成员，表明是一个标识作用

public @interface  注解名 {
String value() default value;
}

### 元注解

JDK 提供了4个可以修饰注解的注解
@Retention 指明该注解的生命周期
@Target 指明注解只能使用在某些对象
@Documented  用于指定对应的注解被提取成文档
@Inherited 被修饰的注解 具有继承性

### JDK 1.8

重复注解
在 myannoation上声明@repeatable 成员值为MyAnnotations.class
Myannoation 的target和Retention和MyAnnotations相同

类型注解
TYPE_USE    注解可以添加在类型前
TYPE_Parameter  注解可以添加在变量声明时

## 集合 （容器）

1 集合\数组都是对多个数据进行存储操作的结构，简称Java容器
说明：此时的存储， 主要指的是内存层面的存储，不涉及道持久化的存储
2 数据在存储多个数据方面的特定
数组    初始化后 长度就确定了
数组一旦定义好，元素的类型也确定了
一旦初始化后，长度不可以修改
数组中提供的方法非常有限
获取数组中实际元素的个数的需求 数组没有提供对应的属性或方法
数组存储数据的特点: 有序 可重复  无法满足 无序 不可重复的需求

Collection 接口 单列集合、用来储存一个一个的对象
List 元素有序、可重复的集合
ArrayList  LinkedList
Set 元素无序、不可重复的集合
HashSet LinkedHashSet TreeSet
Map 接口 用来存储一对数据（key-value）
HashMap LinkedHashMap TreeMap Hashtable Properties

### 集合常用方法

contains 判断集合中是否包含对应元素
containsAll 判断形参中的所有元素是否都存在于当前集合中
remove 返回Boolean 判断是否移除该元素
retainAll 返回两个集合的交集
removeAll 删除对应集合中的所有元素

iterator 迭代器方法
while (collection.interator().hasNext()):
collection.interator().Next()

### List 结构

```
List 接口 存储有序的、可重复的数据
```

——  ArrayList 作为List的主要实现类 线程不安全 效率高 底层使用 object[]
——  LinkedList  底层使用双向链表存储，插入\删除操作比ArrayList 效率高
——  Vector  作为List接口的古老实现类 线程安全、效率低

ArrayList 源码
7   初始化创建一个长度为10的数组
8   初始化创建一个空数组

## Set

Collection 接口 单列集合
Set 接口 存储 无序、不可重复的数据
HashSet 作为Set接口的主要实现类，线程不安全可存储null
LinkHashSet HashSet的子类，遍历其内部数据时 可以按照添加顺序遍历
LinkHashSet 里 定义了一个双向链表来获取每个元素后连结的元素
TreeSet 可以按照添加对象的指定属性，进行排序

无序性 不等于随ijwgio机性
存储的数据在底层数组中并非按照数组索引的顺序添加
不可重复性
保证添的元素按照equals()判断时，不能返回true，即 相同的元素只能添加一个

添加元素的过程，以HashSet 为sd例
先调用元素a的HashCode 方法 计算a元素的哈希值
此哈希值接着要通过某种算法计算出在HashSet底层数组中的存放位置
如果hash值不相同，则元素a添加成功
如果hash值相同，进而需要调用元素a所在类的equals方法
equals 返回true 元素添加失败
equals 返回false 元素添加成功。
